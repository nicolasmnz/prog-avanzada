%% Git es un sistema de control de versiones open-source que nos permite trabajar con historial de cambios dentro de repositorios personales o colaborativos. La mayoria de la gente conoce mas GitHub que Git, siendo que en estricto rigor, github nace de git. 


%$En este laboratorio aprenderemos el uso de git basico que permita aprender a utilizar los repositorios de una forma eficiente y productiva. Git no sera solo contenido de curso, si no que probablemente algo que les funcionara para toda su carrera.

%% Para esta sección, recomendamos saber utilizar al menos los comandos de terminal, ya que este laboratorio sera desarrollado la mayoría desde esta. Ademas, notar que los ejercicios de esta sección estan mas orientados a que sepan como utilizar los comandos y tengan un repositorio al final.

Git es un sistema de control de versiones open-source diseñado para poder gestionar proyectos de codigo con velocidad y eficiencia.

Esta es una guia para poder controlar un repositorio de manera eficiente. Para esto, puedes leer esta guia o utilizar otros medios de aprendizaje que recomendamos en su sección respectiva.

\section{Introducción a git}
\input{docs/git/introduction}
\section{Commits}
\input{docs/git/commit}

\section{Branches}
\input{docs/git/branches}

\section{Git Remoto (Github)}
\input{docs/git/remote}

\section{Fuentes y mas}

\begin{itemize}
	\item \href{https://learngitbranching.js.org/?NODEMO}{learngitbranching}
\end{itemize}

\section{Git Branches}
Una interesante caracteristica de Git es las \textbf{Branches}, estas permiten separar el trabajo entre varias ramas las cuales contendran sus propios archivos. 

Actualmente, al iniciar el repositorio, se creo en la branch \texttt{master} o \texttt{main}. Esta branch es la principal del repositorio. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{img/Branch Main.png}
    \caption{Branch Main}
\end{figure}

En la imagen, C0 indica el commit inicial al realizar un \texttt{git init}, mientras que C1 es el commit en donde agregamos el \texttt{README.md}. El asterisco indica en el commit que nos encontramos, el cual se le conoce como \texttt{HEAD}.

Cuando creemos una branch, esta hara una copia del estado actual del repositorio. Para crear una branch, utilice el comando \texttt{git branch}


\begin{lstlisting}[language=bash, style=terminal, caption={git branch: Crear una nueva branch}]
    user@hostname:~$ git branch <nombre>
\end{lstlisting}

Este comando creara la branch desde el mismo commit en la que se encuentra main.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{img/new_branch.png}
    \caption{Nueva Branch: Feature}
\end{figure}

Ahora, tendremos dos ramas que iran avanzando de manera separada. Todos los commits hechos en la branch \texttt{feature} no se veran en \texttt{main}.

Para moverse hacia la nueva branch, utilice el comando \texttt{checkout}.

\begin{lstlisting}[language=bash, style=terminal, caption={git checkout: Moverse a una nueva branch}]
    user@hostname:~$ git checkout <nombre>
\end{lstlisting}

\begin{ejer}
    En \texttt{verdadero-repositorio}, cree una branch llamada \texttt{feature}. Cambiese a la nueva branch y haga un commit que incluya un codigo en C que imprima Hola mundo. Ademas, en la branch \texttt{main}, haga un commit que cambie el archivo \texttt{README.md} que incluya su nombre y rol.
\end{ejer}

Deberia quedarse la siguiente estructura

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{img/branches.png}
    \caption{Resultado del ejercicio 3}
\end{figure}

Digamos que ahora queremos juntar los cambios realizados en la branch \texttt{feature} hacia la branch \texttt{main}. Para esto, tenemos dos metodos distintos.

\textbf{Git Merge} permite hacer un commit que incluya las diferencias entre el commit de la branch actual, el commit de la branch de destino, y el commit desde que se separaron. Esto se le conoce como \textbf{Merge commit}. 

\begin{lstlisting}[language=bash, style=terminal, caption={git merge: Fusionar la branch actual con otra branch}]
    user@hostname:~$ git merge <branch>
\end{lstlisting}

(Notar que \texttt{git merge} hace el merge hacia la branch actual, o sea, en el comando agregamos que branch queremos fusionar hacia la actual).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{img/merge.png}
    \caption{Resultado de git merge}
\end{figure}

\textbf{Git Rebase}, a diferencia de merge, tomara todos los commits hechos desde que se separo la branch, y hara que estos se hagan commit en la branch seleccionada. Esto hace que parezca que hubo un avance lineal, a diferencia de que dos branches se junten.

\begin{lstlisting}[language=bash, style=terminal, caption={git rebase: Hacer rebase de la branch actual hacia otra}]
    user@hostname:~$ git rebase <branch-destino>
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{img/rebase.png}
    \caption{Resultado de git rebase}
\end{figure}

Cualquiera de estas dos opciones son validas, y llegaran a un resultado equivalente.

\begin{ejer}
    En \texttt{verdadero-repositorio}, junte las dos branches creadas usando el metodo de su preferencia.
\end{ejer}

Finalmente, podemos eliminar las branches de nuestro repositorio. Para esto, usamos la flag \textbf{-d}. Si quiere evitarse un mensaje que indique que hay cambios sin subir, utilice la flag \textbf{-D}

\begin{lstlisting}[language=bash, style=terminal, caption={git branch: Borrar branch}]
    user@hostname:~$ git branch -d <branch>
\end{lstlisting}

\begin{ejer}
    En \texttt{verdadero-repositorio}, elimine la branch de feature.
\end{ejer}

Con estos comandos, habras aprendido lo basico para realizar un repositorio

\section{Resolución de Problemas}

En el mejor de los casos, no habra errores que arreglar dentro de estos commits. En la practica es posible que ocurran momentos en donde haya problemas entre versiones. Los problemas mas comunes que encontramos varian, pero aqui denotamos la solución a varios de ellos.

\subsection{Ver un commit anterior}

Consideremos un estado de un repositorio en el que tenemos tres commits, \texttt{C1}, \texttt{C2} y \texttt{C3}. \texttt{HEAD} se encuentra en C3. 

Digamos que queremos volver a C1 debido que habia una caracteristica que queriamos revisar. Para volver a un commit anterior para observarlo puede usar el comando \textbf{git switch}.

Primero necesitamos saber el id de los commits, que se le conoce como hash. Puede saber esta informacióin mediante \textbf{git log}.

\begin{lstlisting}[language=bash, style=terminal, caption={git log: Ver log del repositorio}]
    user@hostname:~$ git log
\end{lstlisting}

Teniendo el id de este commit, podemos ver el commit utilizando este id.

\begin{lstlisting}[language=bash, style=terminal, caption={git switch: Cambiar a commit}]
    user@hostname:~$ git switch <hash-commit>
\end{lstlisting}

Esto hara que nuestra ubicación actual (o sea, el \texttt{HEAD}) se mueva hacia otra posición. Esto nos permite ver el estado de aquel commit. Para volver al commit principal de la branch actual, utilice el siguiente comando.

\begin{lstlisting}[language=bash, style=terminal, caption={git switch: Volver al ultimo commit de la branch}]
    user@hostname:~$ git switch <branch>
\end{lstlisting}

\subsection{Rehacer un commit anterior}

Digamos estamos en el commit \texttt{C3}, y queremos volver al estado del commit C2. Para esto, tenemos varios comandos. Uno de ellos es \textbf{git revert}, que permite quitar los cambios realizados en un commit. Esto lo hace creando un commit nuevo que borra el commit indicado.

\begin{lstlisting}[language=bash, style=terminal, caption={git revert: Quitar modificaciones de un commit}]
    user@hostname:~$ git revert <hash-commit>
\end{lstlisting}

Otra manera de volver a un estado anterior es utilizando \textbf{git reset}. Este comando, dependiendo de la flag, puede modificar el historial del repositorio, por lo que no lo recomendamos. Puede investigar sobre el usando el comando man.

\subsection{Merge Conflicts}

Aveces cuando juntemos dos branches de repositorios, estas pueden contener archivos que contengan distintas versiones entre si. Esto se conoce como un \texttt{MERGE CONFLICT}.

Dado que le aparezca merge conflict, puede utilizar el comando \textbf{git status} para saber el estado actual.

\begin{lstlisting}[language=bash, style=terminal, caption={git revert: Quitar modificaciones de un commit}]
    user@hostname:~$ git status 
\end{lstlisting}

Aqui podremos ver el estado de error. Simulemos un caso.

\begin{ejer}
    Cree un repositorio en el cual primero haga el commit de un \texttt{README.md}. Despues haga una branch llamada \texttt{Conflict} y agrege como titulo al readme \texttt{\#Conflict}. En su branch principal, agregue de titulo \texttt{\#Main}. Haga un merge y observe el estado usando git status.
\end{ejer}

En el archivo conflictivo que le aparezca en git status, vera que se escribiran formatos de la siguiente manera...

\begin{lstlisting}[language=bash]
    <<<<<<<<<<HEAD
    #Main
    ==========
    #Conflict
    >>>>>>>>> feature
\end{lstlisting}

En este caso, el conflicto esta en la primera linea, en donde la branch actual toma valor de Main, y en la branch feature toma valor de conflict. Para solucionarlo, debe borrar tanto las lineas con $<<<$ y $>>>$, como la linea con $===$, y debe escoger entre cual de las dos soluciones se queda. Tambien puede hacer una nueva, si lo ve necesario.

\begin{ejer}
    Arregle el error del ejercicio anterior. Hagale commit y subalo.
\end{ejer}

\section{Git Remoto}

Finalmente, veremos el trabajo colaborativo de git. Todo este formato de versiones podemos subirlo a otras aplicaciones online que mantengan una copia del estado.

Miremos por ejemplo Github, la cual es la mayormente conocida dentro de este ambito. 

\section{Commits Convencionales}

Ya se tiene conocimiento de los commits. Sin embargo, entregare aqui varios ejemplos de como usar los commits para que nos apoyen mas que hacernos perder tiempo.

\begin{enumerate}
    \item Intenta siempre hacer commits que indiquen bien que hacen. Por ejemplo, puede utilizar \href{https://www.conventionalcommits.org/en/v1.0.0/}{Conventional Commits}
    \item Intente hacer branches que no duren mucho para evitar cambios fuertes entre main y branch. Haga branches enfocadas en una caracteristica especifica, hagale merge, y borre la branch.
\end{enumerate}
